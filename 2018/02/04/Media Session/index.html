<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 如何构建一个Media App · HelloPony</title><meta name="description" content="如何构建一个Media App - PONY WEI"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/bigsmalleye.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/bigsmalleye.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ponywei" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">如何构建一个Media App</h1><div class="post-time">2018年2月4日</div><div class="post-content"><p>在Android系统中构建一个具有多媒体功能的App，如果是使用系统的Media Player，那么就需要了解Android系统对Media的处理流程，会有很多的细节需要开发者关注，比如播放器的各种状态，物理按键的响应等。本文主要是对Android开发者网站API Guide中“Media Apps”章节内容的翻译以及部分个人的理解。</p>
<a id="more"></a>
<h2 id="Media_APP_概览">Media APP 概览</h2><h3 id="Player_和_UI">Player 和 UI</h3><p>一个播放音视频的多媒体App通常包含两个部分：</p>
<ol>
<li>加载数字信息并呈现为音视频的播放器（player）；</li>
<li>展示播放器状态和控制播放器控件的UI</li>
</ol>
<p><img src="http://7u2h4k.com1.z0.glb.clouddn.com/15021978062336.png" alt="Multimedia APP"><br>在Android中，可以选择系统提供的MediaPlayer，也可以使用其它第三方开源库如ExoPlayer来实现一个播放器。</p>
<h3 id="MediaSession_和_MediaController">MediaSession 和 MediaController</h3><p>UI的API和Player是相互独立的，两者之间的交互是所有多媒体App的本质；Android提供两个类：MediaSession 和 MediaController来支持这种结构。<br>MediaSession 和 MediaController之间通过定义的的和标准播放操作（play,pause,stop,etc.）相符合的callbacks来进行通信，也可以扩展出自定义的call来实现独特功能的app：<br><img src="http://7u2h4k.com1.z0.glb.clouddn.com/15021984113212.png" alt="MediaSession and MediaController"></p>
<h4 id="Media_Session">Media Session</h4><p>Media Session负责与Player通信，对app的其它部分隐藏Player的操作，Player也只接受Media Session的控制。它管理着player当前播放的状态和具体信息。一个Media Session可以同时接收到多个Media Controller的callbacks，这也就是说为什么player可以被app的UI控制，也可以同时被其它运行Android Wear和Auto的设备控制。</p>
<h4 id="Media_Controller">Media Controller</h4><p>App的UI只与Media Controller进行通信，它把控件操作（transport controls actions）转换成Media Session的callbacks，也可以在Media Session状态改变时接收session的callbacks，这就有了一个机制来保证关联UI自动更新。一个Media Controller一次只能连接到一个Media Session。</p>
<h2 id="Media_Session-1">Media Session</h2><h3 id="初始化">初始化</h3><p>一个新创建的MediaSession必须要进行以下步骤的初始化工作：</p>
<ol>
<li>设置flags，使得MediaSession可以接受Media Controllers和Media buttons的Callbacks；</li>
<li>创建并初始化一个<code>PlaybackStateCompat</code>的实例赋值给Session。播放状态的改变遍布Session，建议使用<code>PlaybackStateCompat.Builder</code>来复用；</li>
<li>创建一个<code>MediaSessionCompat.Callback</code>的实例赋值给Session。</li>
</ol>
<p>Media Session的创建和初始化工作应该在Activity或Service的<code>onCreate()</code>中进行。为了是media buttons在新启动（或者被停止）的app中能够起作用，<code>PlaybackState</code>必须在初始化的时候就包含<code>ACTION_PLAY</code>，这样才能匹配media buttons发送的Intent。（更多关于Media Button参见<a href="https://developer.android.google.cn/guide/topics/media-apps/mediabuttons.html" target="_blank" rel="external">Responding to Media Buttons</a>）</p>
<h3 id="维护播放状态（Playback_State）和元数据（metadata）">维护播放状态（Playback State）和元数据（metadata）</h3><p>两个类可以代表media session的状态：<br>1.<code>PlaybackStateCompat</code>描述了当前player的运行状态，包括：</p>
<ul>
<li>transport state（player是playing/paused/buffering，等）</li>
<li>player position</li>
<li>当前状态可以处理的有效的controller actions</li>
</ul>
<p>2.<code>MediaMetadataCompat</code>代表了当前正在播放的内容：</p>
<ul>
<li>艺术家&amp;专辑&amp;音轨 的名字</li>
<li>音轨时长</li>
<li>用于锁屏显示的专辑封面，最大320x320dp的bitmap</li>
</ul>
<p>每当Playback state或者Metadata发生改变，都必须创建新的<code>PlaybackStateCompat.Builder()</code>或<code>MediaMetadataCompat.Builder()</code>实例，通过调用<code>setPlaybackState()</code>或者<code>setMetaData()</code>传递给Media session。为了在频繁操作的情况下减少内存的消耗，建议创建全局的builder对象，在整个media session中重用builder对象。</p>
<h3 id="锁屏下的Media_Session">锁屏下的Media Session</h3><p>从4.0（API 14）开始系统便可以访问一个media session的playback state和metadata，这也是为什么锁屏状态下可以显示当前播放的封面（Artwork）和控制器（Transport controls）。<br>在4.0及以上版本，如果metadata中包含这个专辑的artwork bitmap，就会会显示在锁屏状态的整个屏幕背景上；<br>在4.0（API 14）到4.4（API 19），当media session是活动状态且有artwork，那么同时也会自动显示Transport controls；而在5.0（API 21）及以上版本默认不再锁屏显示transport controls，需要使用<a href="https://developer.android.google.cn/guide/topics/media-apps/audio-app/building-a-mediabrowserservice.html#mediastyle-notifications" target="_blank" rel="external">MediaStyle notification</a>。</p>
<h3 id="Media_session_callbacks">Media session callbacks</h3><p>Media session callback的主要方法是onPlay(), onPause(), and onStop()，在这些方法里添加控制Player的方法。<br>除了控制player和管理session状态切换，callbacks也起着控制app与其它app和设备硬件交互方式的作用。（参见<a href="https://developer.android.google.cn/guide/topics/media-apps/volume-and-earphones.html" target="_blank" rel="external">Handling Changes in Audio Output</a>）</p>
<h2 id="创建一个Audio_APP">创建一个Audio APP</h2><p>一个音频app适用于典型的C/S架构。如下图：<br><img src="http://7u2h4k.com1.z0.glb.clouddn.com/15019227170401.png" alt="Audio app C/S"><br><code>MediaBrowserService</code>在这里有两个特点：</p>
<ol>
<li>当你使用MediaBrowserService，其它包含<code>MediaBrowser</code>的组件和应用都可以发现你的Service，创建它们自己的Controller，连接到你app的Media Session，然后控制Player。这也是Android Wear和Auto App获取访问Media App的方式。（补充：这也是为什么连接服务需要<code>onGetRoot</code>方法鉴定权限！）</li>
<li>提供可选的Browsing API，使得client方可以访问Service然后创建自己的内容结构，可以是一个播放列表，也可以是一个媒体库或者精选集等（补充：这也即是<code>onLoadChildren</code>方法的作用）。</li>
</ol>
<blockquote>
<p>Note：这里所指的MediaBrowserService和MediaBrowser在实现过程中推荐使用MediaBrowserServiceCompat和MediaBrowserCompat；MediaSession推荐使用MediaSessionCompat。</p>
</blockquote>
<h3 id="创建Media_Browser_Service">创建Media Browser Service</h3><p>创建自己Service第一步是要新建一个类extends MediaBrowserServiceCompat，然后在APP的manifest中声明你自己的MediaBrowserService，必须包含一个特定的intent-filter。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span> <span class="attribute">android:name</span>=<span class="value">".MediaPlaybackService"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.media.browse.MediaBrowserService"</span> /&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="初始化Media_Session">初始化Media Session</h4><p>在Service的onCreate()生命周期方法里需要完成以下工作：</p>
<ol>
<li>创建并初始化MediaSession</li>
<li>设置MediaSession Callback</li>
<li>设置MediaSession token</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaPlaybackService</span> <span class="keyword">extends</span> <span class="title">MediaBrowserServiceCompat</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MediaSessionCompat mMediaSession;</span><br><span class="line">  <span class="keyword">private</span> PlaybackStateCompat.Builder mStateBuilder;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create a MediaSessionCompat</span></span><br><span class="line">    mMediaSession = <span class="keyword">new</span> MediaSessionCompat(context, LOG_TAG);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Enable callbacks from MediaButtons and TransportControls</span></span><br><span class="line">    mMediaSession.setFlags(</span><br><span class="line">      MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS |</span><br><span class="line">      MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set an initial PlaybackState with ACTION_PLAY, so media buttons can start the player</span></span><br><span class="line">    mStateBuilder = <span class="keyword">new</span> PlaybackStateCompat.Builder()</span><br><span class="line">                    .setActions(</span><br><span class="line">                        PlaybackStateCompat.ACTION_PLAY |</span><br><span class="line">                        PlaybackStateCompat.ACTION_PLAY_PAUSE);</span><br><span class="line">    mMediaSession.setPlaybackState(mStateBuilder.build());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// MySessionCallback() has methods that handle callbacks from a media controller</span></span><br><span class="line">    mMediaSession.setCallback(<span class="keyword">new</span> MySessionCallback());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Set the session's token so that client activities can communicate with it.</span></span><br><span class="line">    setSessionToken(mMediaSession.getSessionToken());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="管理client连接">管理client连接</h4><p>MediaBrowserServiceCompat有两个方法：<code>onGetRoot()</code>控制service的访问；<code>onLoadChildren()</code>给client提供内容。</p>
<h5 id="通过onGetRoot()控制Client访问">通过onGetRoot()控制Client访问</h5><p>该方法返回值（<code>BrowserRoot(@NonNull String rootId, @Nullable Bundle extras)</code>）为内容结构的根节点（root node of content hierarchy），如果返回null为拒绝访问。<br>如果要允许所有的clients访问service及获取内容，这里始终应该返回一个非空的、带有root ID的BrowserRoot；如果要仅允许连接service，不允许浏览内容，那么返回一个非空、但root ID为空的BrowserRoot。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> BrowserRoot <span class="title">onGetRoot</span><span class="params">(String clientPackageName, <span class="keyword">int</span> clientUid,</span><br><span class="line">    Bundle rootHints)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// (Optional) Control the level of access for the specified package name.</span></span><br><span class="line">    <span class="comment">// You'll need to write your own logic to do this.</span></span><br><span class="line">   <span class="keyword">if</span> (allowBrowsing(clientPackageName, clientUid)) &#123;</span><br><span class="line">      <span class="comment">// Returns a root ID, so clients can use onLoadChildren() to retrieve the content hierarchy</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BrowserRoot(MY_MEDIA_ROOT_ID, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Clients can connect, but since the BrowserRoot is an empty string</span></span><br><span class="line">      <span class="comment">// onLoadChildren will return nothing. This disables the ability to browse for content.</span></span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> BrowserRoot(<span class="string">""</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="通过onLoadChildren()获取内容">通过onLoadChildren()获取内容</h5><p>client连接service成功之后就可以通过（可重复）调用<code>MediaBrowserCompat.subscribe()</code>来获取内容结构，进而展示到UI上。MediaBrowser的subscribe方法调用对应service的回调方onLoadChildren响应，得到一个<code>MediaBrowser.MediaItem</code>对象的列表。<br>每一个MeidaItem都有个唯一的ID（Demo中的id是通过对media的source uri进行hashcode得到的，现实中这个id可能是取自服务器方），当client想要打开或者播放一个item时会传入ID，service负责根据ID来取得对应的Item。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLoadChildren</span><span class="params">(<span class="keyword">final</span> String parentMediaId,</span><br><span class="line">    <span class="keyword">final</span> Result&lt;List&lt;MediaItem&gt;&gt; result)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//  Browsing not allowed</span></span><br><span class="line">  <span class="keyword">if</span> (TextUtils.isEmpty(parentMediaId)) &#123;</span><br><span class="line">   result.sendResult(<span class="keyword">null</span>);</span><br><span class="line">   <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Assume for example that the music catalog is already loaded/cached.</span></span><br><span class="line"></span><br><span class="line">  List&lt;MediaItem&gt; mediaItems = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Check if this is the root menu:</span></span><br><span class="line">  <span class="keyword">if</span> (MY_MEDIA_ROOT_ID.equals(parentMediaId)) &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// build the MediaItem objects for the top level,</span></span><br><span class="line">      <span class="comment">// and put them in the mediaItems list</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// examine the passed parentMediaId to see which submenu we're at,</span></span><br><span class="line">      <span class="comment">// and put the children of that menu in the mediaItems list</span></span><br><span class="line">  &#125;</span><br><span class="line">  result.sendResult(mediaItems);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note：通过MediaBrowserService传递的MediaItem不应该直接包含icon bitmap，应该使用MediaDescription的setIconUri()来设置图片的Uri，使用到的时候再根据Uri去获取。</p>
<h4 id="Media_Browser_Service生命周期">Media Browser Service生命周期</h4><p>Android Service的行为表现取决于他是被启动（started）或者绑定到一个或多个客户端（bounded to one or more clients）。当一个Service被创建后，它可以被start，也可以bound，不管何种方式Service的具体任务不受影响，区别仅在于这个service可以存活多久。绑定的服务直到它所绑定的最后一个client被销毁之后才会被自动销毁，而启动的服务可以被显示的停止和销毁。<br>当一个运行在其它Activity中的MediaBrowser连接到MediaBrowserService时，即绑定了该Activity和Service，Service处于被绑定状态。这是集成在MediaBrowserServiceCompat中的默认操作。<br>一个仅仅处于被绑定状态是Service会在所有clients取消绑定后自动销毁。此例中UI activity 断开连接Service就会被销毁。在Audio App中，这显然不合理。用户期望可以一直听到音乐，无论是当前正在使用哪个app，activity有没有被回收。这就要求即使UI取消绑定，Service仍然不会被销毁，player还可以播放。<br>为此，需要在开始play之前，调用<code>startService()</code>来确保Service被启动。一个被启动的Service必须被显示的停止（无论是否存在绑定）。<br>可以调用<code>Context.stopService()</code>或<code>stopSelf()</code>来停止一个启动的service，系统会尽快的停止并回收它。如果仍然有client绑定这个service，停止和回收会被延迟到client取消绑定之后。<br>MediaBrowserService的生命周期取决于创建它的方式、绑定clients的数量，以及它所接收到的MediaSession callback。总结为以下：</p>
<ol>
<li>当为了响应Media button操作而启动，或者一个Activity绑定请求发生时，Service会被创建。</li>
<li>Media Session 的callback方法<code>onPlay()</code>中应该包含<code>startService()</code>，这样才能确保Service可以在所有的UI MediaBrowser activities取消绑定之后依然在存活。</li>
<li>Media Session 的callback方法<code>onStop()</code>中应该调用<code>stopSelf()</code>。</li>
</ol>
<p>下面的图片展示了整个Service的生命周期（counter变量用来记录绑定数）：<br><img src="http://7u2h4k.com1.z0.glb.clouddn.com/15019310141694.png" alt="Service lifecycle flowchart"></p>
<h4 id="在Foreground_Service中使用MediaStyle_notifications">在Foreground Service中使用MediaStyle notifications</h4><p>首先解释一下Foreground Service。这里的Foreground是特殊意义的”前台”，是Android系统为了进程管理的目的把这个Service视为Foreground，而不是对于用户而言的屏幕可见的foreground（实际上Service始终都是工作在后台）。音乐Service正在播放，那么就应该是运行在foreground，系统就会知道当前service正在执行任务，就不会在内存紧张的时候结束服务。<br>当Service运行在foreground，就必须展示一个notification，最好还能有几个控制按钮，当然也应该展示Media Session metadata的一些基本信息。<br>在Player开始播放的时候创建并展示一条通知，最合适的位置就是在<code>MediaSessionCompat.Callback.onPlay()</code>方法里。<br>下面的示例代码展示了如何使用为Media App量身设计的<code>NotificationCompat.MediaStyle</code>，创建并展示metadata和控制按钮。使用<code>getController()</code>方法可以直接从media session中创建一个media controller对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Given a media session and its context (usually the component containing the session)</span></span><br><span class="line"><span class="comment">// Create a NotificationCompat.Builder</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Get the session's metadata</span></span><br><span class="line">MediaControllerCompat controller = mediaSession.getController();</span><br><span class="line">MediaMetadataCompat mediaMetadata = controller.getMetadata();</span><br><span class="line">MediaDescriptionCompat description = mediaMetadata.getDescription();</span><br><span class="line"></span><br><span class="line">NotificationCompat.Builder builder = <span class="keyword">new</span> NotificationCompat.Builder(context);</span><br><span class="line"></span><br><span class="line">builder</span><br><span class="line"><span class="comment">// Add the metadata for the currently playing track</span></span><br><span class="line">    .setContentTitle(description.getTitle())</span><br><span class="line">    .setContentText(description.getSubtitle())</span><br><span class="line">    .setSubText(description.getDescription())</span><br><span class="line">    .setLargeIcon(description.getIconBitmap())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Enable launching the player by clicking the notification</span></span><br><span class="line">    .setContentIntent(controller.getSessionActivity())</span><br><span class="line"></span><br><span class="line"><span class="comment">// Stop the service when the notification is swiped away</span></span><br><span class="line">    .setDeleteIntent(MediaButtonReceiver.buildMediaButtonPendingIntent(<span class="keyword">this</span>,</span><br><span class="line">       PlaybackStateCompat.ACTION_STOP))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make the transport controls visible on the lockscreen</span></span><br><span class="line">    .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add an app icon and set its accent color</span></span><br><span class="line"><span class="comment">// Be careful about the color</span></span><br><span class="line">    .setSmallIcon(R.drawable.notification_icon)</span><br><span class="line">    .setColor(ContextCompat.getColor(<span class="keyword">this</span>, R.color.primaryDark))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add a pause button</span></span><br><span class="line">      .addAction(<span class="keyword">new</span> NotificationCompat.Action(</span><br><span class="line">          R.drawable.pause, getString(R.string.pause),</span><br><span class="line">          MediaButtonReceiver.buildMediaButtonPendingIntent(<span class="keyword">this</span>,</span><br><span class="line">              PlaybackStateCompat.ACTION_PLAY_PAUSE)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// Take advantage of MediaStyle features</span></span><br><span class="line">    .setStyle(<span class="keyword">new</span> NotificationCompat.MediaStyle()</span><br><span class="line">      .setMediaSession(mediaSession.getSessionToken())</span><br><span class="line">      .setShowActionsInCompactView(<span class="number">0</span>)</span><br><span class="line"><span class="comment">// Add a cancel button</span></span><br><span class="line">      .setShowCancelButton(<span class="keyword">true</span>)</span><br><span class="line">      .setCancelButtonIntent(MediaButtonReceiver.buildMediaButtonPendingIntent(<span class="keyword">this</span>,</span><br><span class="line">          PlaybackStateCompat.ACTION_STOP));</span><br><span class="line"></span><br><span class="line"><span class="comment">// Display the notification and place the service in the foreground</span></span><br><span class="line">startForeground(id, builder.build());</span><br></pre></td></tr></table></figure>
<p>（此处还有一些关于MediaStyle的详细介绍，不再展开，参见官方英文原文）</p>
<h3 id="创建Media_Browser_Client">创建Media Browser Client</h3><p>为了完成这个C/S结构，还必须要有一个Activity UI，一个MediaController，以及MediaBrowser。MediaBrowser扮演了两个角色：连接MediaBrowserService，并在这个链接上为UI创建一个MediaController；说白了就是桥梁。</p>
<h4 id="连接MediaBrowserService">连接MediaBrowserService</h4><p>在Activity创建的时候进行Service连接操作，这里有一些握手操作（Activity的生命周期Callback中）需要注意：</p>
<ol>
<li><code>onCreate()</code>构造MediaBrowserCompat，传入定义的MediaBrowserService，以及MediaBrowserCompat.ConnectionCallback。</li>
<li><code>onStart()</code>连接MediaBrowserService，这里也正是MediaBrowserCompat.ConnectionCallback魔法发生的地方：如果连接成功，<code>onConnected()</code>回调中创建media controller，并将之关联到media session，连接UI controls与media controller，然后注册controller以收到media session callback回调。（魔法已内置，无需手动）</li>
<li><code>onStop()</code>断开MediaBrowser连接，取消注册MediaController.Callback。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MediaPlayerActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> MediaBrowserCompat mMediaBrowser;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="comment">// Create MediaBrowserServiceCompat</span></span><br><span class="line">    mMediaBrowser = <span class="keyword">new</span> MediaBrowserCompat(<span class="keyword">this</span>,</span><br><span class="line">      <span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, MediaPlaybackService.class),</span><br><span class="line">        mConnectionCallbacks,</span><br><span class="line">        <span class="keyword">null</span>); <span class="comment">// optional Bundle</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStart();</span><br><span class="line">    mMediaBrowser.connect();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onStop();</span><br><span class="line">    <span class="comment">// (see "stay in sync with the MediaSession")</span></span><br><span class="line">    <span class="keyword">if</span> (MediaControllerCompat.getMediaController(MediaPlayerActivity.<span class="keyword">this</span>) != <span class="keyword">null</span>) &#123;</span><br><span class="line">      MediaControllerCompat.getMediaController(MediaPlayerActivity.<span class="keyword">this</span>).unregisterCallback(controllerCallback);</span><br><span class="line">    &#125;</span><br><span class="line">    mMediaBrowser.disconnect();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note：这里仅是已Activity做为UI来举例，具体实现中换成Fragment的逻辑与上述一致。</p>
</blockquote>
<h4 id="定制MediaBrowserCompat-ConnectionCallback">定制MediaBrowserCompat.ConnectionCallback</h4><p>Activity构造完MediaBrowserCompat之后，然后就需要创建一个ConnectionCallback的实例，在<code>onConnected()</code>回调中获取Media Session的Token，并用这个token去创建MediaControllerCompat，然后用<code>MediaControllerCompat.setMediaController()</code>来保存一个UI与controller的连接。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> MediaBrowserCompat.ConnectionCallback mConnectionCallbacks =</span><br><span class="line">  <span class="keyword">new</span> MediaBrowserCompat.ConnectionCallback() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnected</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Get the token for the MediaSession</span></span><br><span class="line">      MediaSessionCompat.Token token = mMediaBrowser.getSessionToken();</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Create a MediaControllerCompat</span></span><br><span class="line">      MediaControllerCompat mediaController =</span><br><span class="line">        <span class="keyword">new</span> MediaControllerCompat(MediaPlayerActivity.<span class="keyword">this</span>, <span class="comment">// Context</span></span><br><span class="line">        token);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Save the controller</span></span><br><span class="line">      MediaControllerCompat.setMediaController(MediaPlayerActivity.<span class="keyword">this</span>, mediaController);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Finish building the UI</span></span><br><span class="line">      buildTransportControls();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectionSuspended</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// The Service has crashed. Disable transport controls until it automatically reconnects</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConnectionFailed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// The Service has refused our connection</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="连接UI与Media_controller">连接UI与Media controller</h4><p>在UI上通过MediaControllerCompat.TransportControls 方法来控制controller。</p>
<h4 id="与Media_Session同步">与Media Session同步</h4><p>UI理应展示media session的最新状态，包括PlaybackState与Metadata。当你创建transport contraols时你可以获取到当前session的状态，来对应调整ui以及controls的可以操作等；创建之后，就需要一个来自Media Session的callback来获取状态的改变了，它就是<code>MediaControllerCompat.Callback</code>。这个回调也应当在onConnected之后注册到controller。</p>
<h3 id="Media_Session_Callbacks">Media Session Callbacks</h3><p>在media session callback中要调用许多的API，去控制Player，管理audio focus，管理session与media browser service的通信等。下表总结了这些工作在callbacks中如何分布。<br><img src="http://7u2h4k.com1.z0.glb.clouddn.com/screencapture-developer-android-google-cn-guide-topics-media-apps-audio-app-mediasession-callbacks-html-1502180848097.png" alt="screencapture-developer-android-google-cn-guide-topics-media-apps-audio-app-mediasession-callbacks-html-1502180848097"></p>
<h2 id="响应Media_Buttons">响应Media Buttons</h2><p>这里的buttons包含且不仅限于Android设备上的物理按钮、有线/蓝牙耳机上的按钮、其他周边设备按钮。用户的点击按钮操作会在Android上产生一个包含标识的KeyEvent，key code以<code>KEYCODE_MEDIA</code>开头（如KEYCODE_MEDIA_PLAY）。</p>
<p>Android系统分发Media button Event规则：</p>
<ol>
<li>首先分发给当前屏幕显示的Activity（foreground activity）；</li>
<li>如果当前Activity没有处理，系统会尝试发送给一个活动状态的MediaSession（调用<code>setActive(true)后</code>。如果有多个活动的MediaSession，系统会优先选择状态为准备播放（buffering/connecting)、播放中（playing）或者暂停（paused），而不会是停止（stopped）。</li>
<li>如果没有活动状态的MediaSession，系统会尝试发送给最近一次活动的MediaSession。在5.0（API21）及以上则是发送给调用了<code>setMediaButtonReceiver()</code>方法的Session。</li>
</ol>
<p>由于系统版本的割裂，在不同版本上也有不同的版本的处理方法，这里仅对方案总结如下：</p>
<ul>
<li><p><strong>通用</strong>：</p>
<ul>
<li><p>在初始化时对MediaSession设置标签：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mediaSession.setFlags(MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS);</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Service的<code>onStartCommand()</code>中添加代码（这里MediaButtonReceiver的作用是解释intent并生成对应MediaSession的callbak，onPlay onPause等）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">  MediaButtonReceiver.handleIntent(mMediaSessionCompat, intent);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p><strong>5.0及以上</strong>：</p>
<ul>
<li>在MediaController的callback方法<code>onConnected()</code>中调用<code>MediaControllerCompat.setMediaController()</code>（交由系统默认处理）；</li>
<li>如果需要允许Media Button的Event重新启动非活动状态的Media Session，手动调用<code>setMediaButtonReceiver(PendingIntent intent)</code>。</li>
</ul>
</li>
<li><p><strong>5.0以下</strong>：</p>
<ul>
<li><p>在Activity中override <code>onKeyDownEvent()</code>以接收处理Media buttons event（必须return true，标识event已被处理）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">onKeyDown</span><span class="params">(<span class="keyword">int</span> keyCode, KeyEvent event)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (keyCode) &#123;</span><br><span class="line">            <span class="keyword">case</span> KeyEvent.KEYCODE_MEDIA_PLAY:</span><br><span class="line">                    yourMediaController.dispatchMediaButtonEvent(event);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>在Manifest文件中声明全局的<code>MediaButtonReceiver</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">receiver</span> <span class="attribute">android:name</span>=<span class="value">"android.support.v4.media.session.MediaButtonReceiver"</span> &gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.intent.action.MEDIA_BUTTON"</span> /&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h2 id="处理音频输出中的变化">处理音频输出中的变化</h2><p>除了要响应UI Controls和Media Button，一个音频App还需要对其它可能影响到声音的Android事件做出响应，主要有以下三种：</p>
<ol>
<li>当用户通过点击物理按钮改变音量时对应调整音量；</li>
<li>当正在使用中的耳机断开连接时暂停播放；</li>
<li>当其它应用拿到了音频输出流时停止播放或降低音量。</li>
</ol>
<h3 id="响应音量控制按钮">响应音量控制按钮</h3><p>Android对不同的用途使用不同的音频流（Audio Stream），播放音乐，闹钟，通知，来电铃声，系统声音，通话音量等。用户可以独立的控制每一个stream的音量。默认情况下，按下音量控制按钮会改变当前活动状态的音频流，如果当前没有任何正在播放，就调整铃声音量。<br>除非你的app是一个闹钟程序，否则都应该使用<code>STREAM_MUSIC</code>来播放音频。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setVolumeControlStream(AudioManager.STREAM_MUSIC);</span><br></pre></td></tr></table></figure>
<p>这是一个Activity方法，最好是在onCreate()中就调用，这样当Activity或Fragment可见时，音量按钮就可以连接上STREAM_MUSIC。</p>
<h3 id="不要太吵">不要太吵</h3><p>当有线耳机被拔掉，或者蓝牙耳机断开连接时，音频流会自动切换到内置扬声器。如果你正在以一个很高的音量听音乐，那这就很吵很尴尬了。<br>好在，当以上情况发生时，系统会发出一条<code>ACTION_AUDIO_BECOMING_NOISY</code>intent广播，创建一个Receiver接收这条广播，在回调中控制暂停或者降低音量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">BecomingNoisyReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intent.getAction())) &#123;</span><br><span class="line">          <span class="comment">// Pause the playback</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在开始播放时注册Receiver，在停止时取消注册。按照指导规范，对应的是MediaSession Callbacks的onPlay()和onStop()。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IntentFilter intentFilter = <span class="keyword">new</span> IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY);</span><br><span class="line"><span class="keyword">private</span> BecomingNoisyReceiver myNoisyAudioStreamReceiver = <span class="keyword">new</span> BecomingNoisyReceiver();</span><br><span class="line"></span><br><span class="line">MediaSessionCompat.Callback callback = <span class="keyword">new</span></span><br><span class="line">MediaSessionCompat.Callback() &#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerReceiver(myNoisyAudioStreamReceiver, intentFilter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    unregisterReceiver(myNoisyAudioStreamReceiver);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="共享Audio_Focus">共享Audio Focus</h3><p>为了避免多个App同时播放造成混乱，Android引入音频焦点（Audio Focus）的概念，在一个时间点最多只有一个App可以拥有焦点。</p>
<p>一个规范的音频App应当遵循以下规则来管理音频焦点：</p>
<ol>
<li>开始播放之前，请求焦点，验证是否授予成功；</li>
<li>当其它app获得焦点，停止播放或者降低音量播放；</li>
<li>停止播放时，释放焦点。</li>
</ol>
<p>以上原则仅为从用户体验角度来鼓励遵照，但也不强制。</p>
<h4 id="获取和释放焦点">获取和释放焦点</h4><p>在进行播放之前，Media Session的onPlay()回调方法中调用<code>requestAudioFocus()</code>并验证<code>AUDIOFOCUS_REQUEST_GRANTED</code>是否成功：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">AudioManager.OnAudioFocusChangeListener afChangeListener;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Request audio focus for playback</span></span><br><span class="line"><span class="keyword">int</span> result = am.requestAudioFocus(afChangeListener,</span><br><span class="line">                             <span class="comment">// Use the music stream.</span></span><br><span class="line">                             AudioManager.STREAM_MUSIC,</span><br><span class="line">                             <span class="comment">// Request permanent focus.</span></span><br><span class="line">                             AudioManager.AUDIOFOCUS_GAIN);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) &#123;</span><br><span class="line">    <span class="comment">// Start playback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参数1 <strong>AudioManager.OnAudioFocusChangeListener</strong> 焦点变化回调，应该创建在拥有Media Session的Activity或Service中，下个小节展开。</p>
<p>参数3 <strong>duration hint</strong>，指定请求焦点的使用范围：</p>
<ul>
<li><code>AUDIOFOCUS_GAIN</code>永久焦点，在可预见的未来一直播放，期望上一个焦点应用停止播放；</li>
<li><code>AUDIOFOCUS_GAIN_TRANSIENT</code>暂时焦点，预计短时间播放，期望上一个焦点应用暂停播放；</li>
<li><code>AUDIOFOCUS_GAIN_TRANSIENT_MAY_DUCK</code>带‘DUCK’的暂时焦点，预计短时播放，且不需要上一个焦点应用暂停或停止，可以降低音量同时播放（Duck means Lower）。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">AudioManager am = (AudioManager) mContext.getSystemService(Context.AUDIO_SERVICE);</span><br><span class="line">AudioManager.OnAudioFocusChangeListener afChangeListener;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="comment">// Request audio focus for playback</span></span><br><span class="line"><span class="keyword">int</span> result = am.requestAudioFocus(afChangeListener,</span><br><span class="line">                             <span class="comment">// Use the music stream.</span></span><br><span class="line">                             AudioManager.STREAM_MUSIC,</span><br><span class="line">                             <span class="comment">// Request permanent focus.</span></span><br><span class="line">                             AudioManager.AUDIOFOCUS_GAIN);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) &#123;</span><br><span class="line">    <span class="comment">// Start playback</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>播放结束，请求释放焦点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Abandon audio focus when playback complete</span></span><br><span class="line">am.abandonAudioFocus(afChangeListener);</span><br></pre></td></tr></table></figure>
<h4 id="响应音频焦点变化">响应音频焦点变化</h4><p>一个请求音频焦点的app必须要在其它app请求焦点的时候可以自己释放焦点。这就是AudioManager.OnAudioFocusChangeListener的意义所在。<br>如下代码所示，参数<strong>focusChange</strong>指正在发生的变化，也就是正在请求获取焦点的app所指定的duration hint，当前app应当对应的做出响应：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Handler mHandler = <span class="keyword">new</span> Handler();</span><br><span class="line">AudioManager.OnAudioFocusChangeListener afChangeListener =</span><br><span class="line">  <span class="keyword">new</span> AudioManager.OnAudioFocusChangeListener() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAudioFocusChange</span><span class="params">(<span class="keyword">int</span> focusChange)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (focusChange == AudioManager.AUDIOFOCUS_LOSS) &#123;</span><br><span class="line">        <span class="comment">// Permanent loss of audio focus</span></span><br><span class="line">        <span class="comment">// Pause playback immediately</span></span><br><span class="line">        mediaController.getTransportControls().pause();</span><br><span class="line">        <span class="comment">// Wait 30 seconds before stopping playback</span></span><br><span class="line">        mHandler.postDelayed(mDelayedStopRunnable,</span><br><span class="line">          TimeUnit.SECONDS.toMillis(<span class="number">30</span>));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (focusChange == AUDIOFOCUS_LOSS_TRANSIENT) &#123;</span><br><span class="line">        <span class="comment">// Pause playback</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (focusChange == AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK) &#123;</span><br><span class="line">        <span class="comment">// Lower the volume, keep playing</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (focusChange == AudioManager.AUDIOFOCUS_GAIN) &#123;</span><br><span class="line">        <span class="comment">// Your app has been granted audio focus again</span></span><br><span class="line">        <span class="comment">// Raise volume to normal, restart playback if necessary</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable mDelayedStopRunnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mediaController.getTransportControls().stop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>为了确保用户重启播放时，延时停止操作不会发生，必须要在任意状态变化响应时调用<code>mHandler.removeCallbacks(mDelayedStopRunnable)</code>。</p>
<h2 id="参考">参考</h2><ul>
<li><a href="https://developer.android.google.cn/guide/topics/media-apps/media-apps-overview.html" target="_blank" rel="external">开发者文档 Media Apps</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2018/03/27/ARouter/" class="prev">上一篇</a><a href="/2017/06/20/Android图片拍摄一二/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://hellopony.cn">PONY WEI</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>