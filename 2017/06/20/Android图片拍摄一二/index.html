<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Android图片拍摄一二 · HelloPony</title><meta name="description" content="Android图片拍摄一二 - PONY WEI"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/bigsmalleye.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/bigsmalleye.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ponywei" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Android图片拍摄一二</h1><div class="post-time">2017年6月20日</div><div class="post-content"><p>关于在Android开发中调用摄像头进行图片拍摄，保存到指定路径，通过FileProvider获取原始图片以及提供图片给其它使用方等过程的细节进行梳理。</p>
<a id="more"></a>
<h3 id="1-_请求Camera权限">1. 请求Camera权限</h3><p>如果拍照是app的主要功能，那Google Play就需要知道目标设备是否有摄像头。<br>android:required是告诉Google Play是否强制下载该app的设备需要硬件支持；如果false，则需要在运行时进行判断是否有摄像头<code>hasSystemFeature(PackageManager.FEATURE_CAMERA)</code>。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">...</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-feature</span> <span class="attribute">android:name</span>=<span class="value">"android.hardware.camera"</span></span><br><span class="line">                  <span class="attribute">android:required</span>=<span class="value">"true"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-_使用Camera_App拍照">2. 使用Camera App拍照</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_IMAGE_CAPTURE = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchTakePictureIntent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent takePictureIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    <span class="keyword">if</span> (takePictureIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-_获取缩略图">3. 获取缩略图</h3><p>注意：这里从”data”中获取出来的仅是照片的缩略图，可能足够满足小图展示的需求；默认情况下Android Camera App会把照片保存在外部公共存储的相册<code>Environment.getExternalStoragePublicDirectory(Environment.DIRECTORY_DCIM)</code>；此时需要声明or动态申请 <code>WRITE_EXTERNAL_STORAGE</code> 权限。<br>如果需要取得全尺寸的完整图片，<code>data.getData()</code> 即可得到原图的Uri，形如“<code>content://media/external/images/media/6363</code>”，绝对路径如<code>/storage/emulated/0/DCIM/Camera/20170516_114052.jpg</code>（PS：目前仅在samsung上测试）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (requestCode == REQUEST_IMAGE_CAPTURE &amp;&amp; resultCode == RESULT_OK) &#123;</span><br><span class="line">        Bundle extras = data.getExtras();</span><br><span class="line">        Bitmap imageBitmap = (Bitmap) extras.get(<span class="string">"data"</span>);</span><br><span class="line">        mImageView.setImageBitmap(imageBitmap);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-_保存全尺寸图片">4. 保存全尺寸图片</h3><p>如果需要将照片保存到App的私有路径，其它App无法读取，需要给Camera指定一个完整的保存路径<code>getExternalFilesDir()</code>。4.4开始写入这个路径将不再需要手动申请<code>WRITE_EXTERNAL_STORAGE</code>权限，因为这个路径是绝对私有，对其它app来说是不可访问的。所以可以这样声明权限：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">manifest</span> <span class="attribute">...</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">uses-permission</span> <span class="attribute">android:name</span>=<span class="value">"android.permission.WRITE_EXTERNAL_STORAGE"</span></span><br><span class="line">                     <span class="attribute">android:maxSdkVersion</span>=<span class="value">"18"</span> /&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>指定照片的保存路径，然后还需要生成一个无冲突的唯一文件名，顺手再留下一个图片路径以备后用。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">String mCurrentPhotoPath;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">createImageFile</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Create an image file name</span></span><br><span class="line">    String timeStamp = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyyMMdd_HHmmss"</span>).format(<span class="keyword">new</span> Date());</span><br><span class="line">    String imageFileName = <span class="string">"JPEG_"</span> + timeStamp + <span class="string">"_"</span>;</span><br><span class="line">    File storageDir = getExternalFilesDir(Environment.DIRECTORY_PICTURES);</span><br><span class="line">    File image = File.createTempFile(</span><br><span class="line">        imageFileName,  <span class="comment">/* prefix */</span></span><br><span class="line">        <span class="string">".jpg"</span>,         <span class="comment">/* suffix */</span></span><br><span class="line">        storageDir      <span class="comment">/* directory */</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save a file: path for use with ACTION_VIEW intents</span></span><br><span class="line">    mCurrentPhotoPath = image.getAbsolutePath();</span><br><span class="line">    <span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发起Intent的方法也要调整：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REQUEST_TAKE_PHOTO = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchTakePictureIntent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent takePictureIntent = <span class="keyword">new</span> Intent(MediaStore.ACTION_IMAGE_CAPTURE);</span><br><span class="line">    <span class="comment">// Ensure that there's a camera activity to handle the intent</span></span><br><span class="line">    <span class="keyword">if</span> (takePictureIntent.resolveActivity(getPackageManager()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Create the File where the photo should go</span></span><br><span class="line">        File photoFile = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            photoFile = createImageFile();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">            <span class="comment">// Error occurred while creating the File</span></span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Continue only if the File was successfully created</span></span><br><span class="line">        <span class="keyword">if</span> (photoFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Uri photoURI = FileProvider.getUriForFile(<span class="keyword">this</span>,</span><br><span class="line">                                                  <span class="string">"com.example.android.fileprovider"</span>,</span><br><span class="line">                                                  photoFile);</span><br><span class="line">            takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);</span><br><span class="line">            startActivityForResult(takePictureIntent, REQUEST_TAKE_PHOTO);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：这里使用的<code>getUriForFile(Context, String, File)</code>返回的是形如<code>content://</code>的URI，对于target Android 7.0（API 24）及以上的app，跨越package传递<code>file://</code>URI会抛出<code>FileUriExposedException</code>，需要统一使用<strong>FileProvider</strong>来处理。关于FileProvider的详细分析见附录。</p>
</blockquote>
<p>首先要在manifest中配置FileProvider：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">application</span>&gt;</span></span><br><span class="line">   ...</span><br><span class="line">   <span class="tag">&lt;<span class="title">provider</span></span><br><span class="line">        <span class="attribute">android:name</span>=<span class="value">"android.support.v4.content.FileProvider"</span></span><br><span class="line">        <span class="attribute">android:authorities</span>=<span class="value">"com.example.android.fileprovider"</span></span><br><span class="line">        <span class="attribute">android:exported</span>=<span class="value">"false"</span></span><br><span class="line">        <span class="attribute">android:grantUriPermissions</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">meta-data</span></span><br><span class="line">            <span class="attribute">android:name</span>=<span class="value">"android.support.FILE_PROVIDER_PATHS"</span></span><br><span class="line">            <span class="attribute">android:resource</span>=<span class="value">"@xml/file_paths"</span>&gt;</span><span class="tag">&lt;/<span class="title">meta-data</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">provider</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="title">application</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里要确保<code>android:authorities</code>设置的字符串与<code>getUriForFile(Context, String, File)</code>的第二个参数authorities一致。然后，如meta-data配置的一样，provider需要从资源文件 res/xml/file_paths.xml中读取路径来做为配置。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">paths</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">external-path</span> <span class="attribute">name</span>=<span class="value">"my_images"</span> <span class="attribute">path</span>=<span class="value">"Android/data/com.example.package.name/files/Pictures"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这里的path组件与<code>getExternalFilesDir( Environment.DIRECTORY_PICTURES)</code>返回的路径是相符的。<a href="https://developer.android.google.cn/reference/android/support/v4/content/FileProvider.html" target="_blank" rel="external">关于FileProvider的文档</a></p>
<h3 id="5-_添加照片到相册">5. 添加照片到相册</h3><p>（Don’t know why在我的samsung测试机上不生效）<br>在创建照片的时候我们已经指定了照片的第一保存位置，这对当前app使用来说是最方便且可控的，而且保存在<code>getExternalFilesDir()</code>路径下的文件不会被media scanner扫描到。但是对于其它app来说，访问到这些照片最简单的方式就是通过系统的<strong>Media Provider</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">galleryAddPic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Intent mediaScanIntent = <span class="keyword">new</span> Intent(Intent.ACTION_MEDIA_SCANNER_SCAN_FILE);</span><br><span class="line">    File f = <span class="keyword">new</span> File(mCurrentPhotoPath);</span><br><span class="line">    Uri contentUri = Uri.fromFile(f);</span><br><span class="line">    mediaScanIntent.setData(contentUri);</span><br><span class="line">    <span class="keyword">this</span>.sendBroadcast(mediaScanIntent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="6-_动态调整图片">6. 动态调整图片</h3><p>操作或显示全尺寸图对内存的损耗巨大，所以我们可以通过把jpeg图片按照目标显示视图的大小来动态的调整，以减少内存的使用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setPic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Get the dimensions of the View</span></span><br><span class="line">    <span class="keyword">int</span> targetW = mImageView.getWidth();</span><br><span class="line">    <span class="keyword">int</span> targetH = mImageView.getHeight();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get the dimensions of the bitmap</span></span><br><span class="line">    BitmapFactory.Options bmOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    bmOptions.inJustDecodeBounds = <span class="keyword">true</span>;</span><br><span class="line">    BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions);</span><br><span class="line">    <span class="keyword">int</span> photoW = bmOptions.outWidth;</span><br><span class="line">    <span class="keyword">int</span> photoH = bmOptions.outHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Determine how much to scale down the image</span></span><br><span class="line">    <span class="keyword">int</span> scaleFactor = Math.min(photoW/targetW, photoH/targetH);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decode the image file into a Bitmap sized to fill the View</span></span><br><span class="line">    bmOptions.inJustDecodeBounds = <span class="keyword">false</span>;</span><br><span class="line">    bmOptions.inSampleSize = scaleFactor;</span><br><span class="line">    bmOptions.inPurgeable = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeFile(mCurrentPhotoPath, bmOptions);</span><br><span class="line">    mImageView.setImageBitmap(bitmap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="附录：关于File_Provider">附录：关于File Provider</h3><p>File Provider是Content Provider的子类，通过创建content:// Uri来代替file:// Uri进而提升文件访问的安全性。<br>Content URI允许授予临时读写权限。当一个包含Content URI的Intent发送到目标app时（也可以通过 Intent.setFlags()来添加权限）。这些权限在目标app接受该Intent的Activity active期间一致可用；如果是Service，权限在Servce Running期间可用。<br>相反，如果需要控制 file:/// Uri就必须修改指定路径或文件的文件系统权限，同时这个权限针对所有其它app可用，这种情况会持续到你再次修改它。这样的文件访问是完全不安全的。<br>FileProvider通过Content URI提供的更高安全性的文件访问控制是Android系统安全的关键部分。</p>
<h4 id="a-_定义FileProvider">a. 定义FileProvider</h4><p>在app的manifest文件中添加<code>&lt;provider&gt;</code>即可，设置<code>android:name</code>属性为<code>android.support.v4.content.FileProvider</code>；<code>android:authorities</code>取决与你所控制的域名（app package name)；FileProvider不需要公开，所以<code>android:exported</code>设置为false；<code>android:grantUriPermissions</code>设置为true去允许为文件授予临时访问权限。<br>一个完整的FileProvider定义如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;provider</span><br><span class="line">    android:name="android.support.v4.content.FileProvider"</span><br><span class="line">    android:authorities="com.mydomain.fileprovider"</span><br><span class="line">    android:exported="false"</span><br><span class="line">    android:grantUriPermissions="true"&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name="android.support.FILE_PROVIDER_PATHS"</span><br><span class="line">        android:resource="@xml/file_paths" /&gt;</span><br><span class="line">&lt;/provider&gt;</span><br></pre></td></tr></table></figure>
<h4 id="b-_指定可用文件">b. 指定可用文件</h4><p>FileProvider仅对指定的路径生成Content URI；这个指定工作在xml中完成。<br><strong>在工程中添加<code>res/xml/file_paths.xml</code></strong>（在<provider>的<meta-data>中指定的path资源），代码如下：</meta-data></provider></p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">paths</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">files-path</span> <span class="attribute">name</span>=<span class="value">"my_images"</span> <span class="attribute">path</span>=<span class="value">"images/"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">files-path</span> <span class="attribute">name</span>=<span class="value">"my_docs"</span> <span class="attribute">path</span>=<span class="value">"docs/"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">paths</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><paths>必须包含一个或多个子元素：</paths></p>
<ul>
<li><code>&lt;files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：app内部存储的<code>files/</code>子目录；与<code>Context.getFilesDir()</code>一致。</li>
<li><code>&lt;cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：app内部存储的缓存子目录；与<code>getCacheDir()</code>一致。</li>
<li><code>&lt;external-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：外部存储的根目录；与<code>Environment.getExternalStorageDirectory()</code>一致。</li>
<li><code>&lt;external-files-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：app的外部存储根目录，与<code>Context#getExternalFilesDir(String type) Context.getExternalFilesDir(null)</code>一致。</li>
<li><code>&lt;external-cache-path name=&quot;name&quot; path=&quot;path&quot; /&gt;</code>：app的外部缓存根目录，与<code>Context.getExternalCacheDir()</code>一致。</li>
</ul>
<p>所有以上子元素都包含两个属性：</p>
<ul>
<li>name=”name”：URI路径片段。为了安全，生成的Uri会以name值隐藏正在共享的目录的真实路径。</li>
<li>path=”path”：共享的真实目录。path值永远指向一个子目录，而不是特定的文件；不能通过文件名来共享指定的某个文件，也不能使用通配符来指定一部分文件。</li>
</ul>
<h4 id="c-_生成文件的Content_URI">c. 生成文件的Content URI</h4><p>APP必须生成Content URI来与其它app共享数据。生成URI的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File imagePath = <span class="keyword">new</span> File(Context.getFilesDir(), <span class="string">"images"</span>);</span><br><span class="line">File newFile = <span class="keyword">new</span> File(imagePath, <span class="string">"default_image.jpg"</span>);</span><br><span class="line">Uri contentUri = getUriForFile(getContext(), <span class="string">"com.mydomain.fileprovider"</span>, newFile);</span><br></pre></td></tr></table></figure>
<p>APP可以将这个URI通过Intent发送给Client app，接受方通过调用<code>ContentResolver.openFileDescriptor</code>来得到一个<code>ParcelFileDescriptor</code>进而访问文件内容。具体接收方app的接收处理见Demo。<br><a href="https://developer.android.google.cn/reference/android/content/ContentResolver.html#openFileDescriptor(android.net.Uri, java.lang.String" target="_blank" rel="external">关于ContentResolver.openFileDescriptor</a>)</p>
<h4 id="d-_为URI授予临时权限">d. 为URI授予临时权限</h4><p>为通过<code>getUriForFile()</code>得到的content URI授予访问权限：</p>
<ol>
<li>Content Uri设置到Intent.setData()</li>
<li>调用Intent.setFlags()，入参 FLAG_GRANT_READ_URI_PERMISSION or FLAG_GRANT_WRITE_URI_PERMISSION or both。</li>
<li>发送Intent到另一个app，通常是setResult(intent)。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">Uri imageUri = FileProvider.getUriForFile(<span class="keyword">this</span>, FILE_PROVIDER_AUTHORITY, <span class="keyword">new</span> File(currentPhotoPath));</span><br><span class="line">intent.setData(imageUri);</span><br><span class="line">intent.setFlags(Intent.FLAG_GRANT_READ_URI_PERMISSION);</span><br><span class="line">setResult(RESULT_OK, intent);</span><br></pre></td></tr></table></figure>
<h4 id="e-_DEMO">e. DEMO</h4><ul>
<li><a href="https://github.com/ponywei/MyFileProviderDemo" target="_blank" rel="external">FileProvider图片拍摄及提供方示例</a></li>
<li><a href="https://github.com/ponywei/MyFileProviderClient" target="_blank" rel="external">FileProvider图片接受方示例</a></li>
</ul>
<h3 id="参考资料">参考资料</h3><ul>
<li><a href="https://developer.android.google.cn/training/camera/photobasics.html" target="_blank" rel="external">“Taking Photos Simply” training class.</a></li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2018/02/04/ARouter/" class="prev">上一篇</a><a href="/2016/08/24/Android WebView相关姿势/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2018 <a href="http://hellopony.cn">PONY WEI</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>