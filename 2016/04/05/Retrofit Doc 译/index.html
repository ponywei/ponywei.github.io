<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> Retrofit Doc 译 · HelloPony</title><meta name="description" content="Retrofit Doc 译 - PONY WEI"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="short icon" href="/bigsmalleye.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+Pro:400,600" type="text/css"></head><body><header><a href="/" class="logo-link"><img src="/bigsmalleye.png"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/archives/" target="_self" class="nav-list-link">ARCHIVE</a></li><li class="nav-list-item"><a href="https://github.com/ponywei" target="_blank" class="nav-list-link">GITHUB</a></li></ul></header><section class="container"><div class="post"><article class="post-block"><h1 class="post-title">Retrofit Doc 译</h1><div class="post-time">2016年4月5日</div><div class="post-content"><p>为加深对Retrofit网络请求框架的理解，遂将官网Doc通读一遍并翻译成中文。</p>
<a id="more"></a>
<h2 id="引言">引言</h2><p>Retrofit将你的HTTP API换成Java接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="annotation">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Retrofit</strong> 类生成一个 <strong>GitHubService</strong> 接口的实例。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure>
<p><strong>GitHubService</strong> 中的每一个 <strong>Call</strong> 都可以用来创建同步或者异步的HTTP请求。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</span><br></pre></td></tr></table></figure>
<p>使用注解(annotations)的方式来来描述一个HTTP请求：</p>
<ul>
<li>支持URL参数替换和查询参数</li>
<li>对象转换为请求body (例如 JSON，protocol buffers)</li>
<li>多请求体和文件上传<br><em>Note：</em> 后续新版2.0的API扩展仍在进行中。</li>
</ul>
<h2 id="API_说明">API 说明</h2><p>接口中方法以及其参数的注解用于表明这个请求会被处理的方式。</p>
<h4 id="请求方法">请求方法</h4><p>每个方法都必须有一个声明了请求类型和相对URL地址的HTTP注解，内置支持五种类型注解：<strong>GET，POST，PUT，DELETE，HEAD</strong>，相对URL地址在注解中进行指定。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GET</span>(<span class="string">"users/list"</span>)</span><br></pre></td></tr></table></figure>
<p>也可以直接在URL中写请求参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GET</span>(<span class="string">"users/list?sort=desc"</span>)</span><br></pre></td></tr></table></figure>
<h4 id="URL操作">URL操作</h4><p>通过在方法中使用替换块和参数，可以实现请求URL地址的动态更新。一个替换块(replacement block)是一个由花括号“{…}”包裹的字符串，与之通信的参数必须使用 <strong>@Path</strong> 注解相同的字符串。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GET</span>(<span class="string">"group/&#123;id&#125;/users"</span>)</span><br><span class="line">Call&lt;List&lt;User&gt;&gt; groupList(<span class="annotation">@Path</span>(<span class="string">"id"</span>) <span class="keyword">int</span> groupId);</span><br></pre></td></tr></table></figure>
<p>同时也可以添加查询参数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GET</span>(<span class="string">"group/&#123;id&#125;/users"</span>)</span><br><span class="line">Call&lt;List&lt;User&gt;&gt; groupList(<span class="annotation">@Path</span>(<span class="string">"id"</span>) <span class="keyword">int</span> groupId, <span class="annotation">@Query</span>(<span class="string">"sort"</span>) String sort);</span><br></pre></td></tr></table></figure>
<p>更复杂的参数组合可以使用 <strong>Map</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GET</span>(<span class="string">"group/&#123;id&#125;/users"</span>)</span><br><span class="line">Call&lt;List&lt;User&gt;&gt; groupList(<span class="annotation">@Path</span>(<span class="string">"id"</span>) <span class="keyword">int</span> groupId, <span class="annotation">@QueryMap</span> Map&lt;String, String&gt; options);</span><br></pre></td></tr></table></figure>
<h4 id="请求体（Request_Body)">请求体（Request Body)</h4><p>使用 <strong>@Body</strong> 注解来指定一个对象，用作HTTP请求体。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@POST</span>(<span class="string">"users/new"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">createUser</span><span class="params">(@Body User user)</span></span>;</span><br></pre></td></tr></table></figure>
<p>该对象也会被 <strong>Retrofit</strong> 实例中指定的转换器(Converter)进行转换。如果没有指定转换器，则只能使用 <strong>RequestBody</strong> 。</p>
<h4 id="表单数据及操作">表单数据及操作</h4><p>可以声明方法来发送表单以及多请求体数据。<br>当方法上出现 <strong>@FormUrlEncoded</strong> 时会发送表单形式的数据，键值对通过 <strong>Field</strong> 注解来声明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@FormUrlEncoded</span></span><br><span class="line"><span class="annotation">@POST</span>(<span class="string">"user/edit"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">updateUser</span><span class="params">(@Field(<span class="string">"first_name"</span>)</span> String first, @<span class="title">Field</span><span class="params">(<span class="string">"last_name"</span>)</span> String last)</span>;</span><br></pre></td></tr></table></figure>
<p>当方法上出现 <strong>@Multipart</strong> 时会以多请求体的形式发送数据。每一部分使用 <strong>@Part</strong> 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Multipart</span></span><br><span class="line"><span class="annotation">@PUT</span>(<span class="string">"user/photo"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">updateUser</span><span class="params">(@Part(<span class="string">"photo"</span>)</span> RequestBody photo, @<span class="title">Part</span><span class="params">(<span class="string">"description"</span>)</span> RequestBody description)</span>;</span><br></pre></td></tr></table></figure>
<p>此部分需要使用 <strong>Retrofit</strong></p>
<h4 id="请求头部操作">请求头部操作</h4><p>可以使用 <strong>@Header</strong> 注解为每一个方法设置静态请求头部。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Headers</span>(<span class="string">"Cache-Control: max-age=640000"</span>)</span><br><span class="line"><span class="annotation">@GET</span>(<span class="string">"widget/list"</span>)</span><br><span class="line">Call&lt;List&lt;Widget&gt;&gt; widgetList();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Headers</span>(&#123;</span><br><span class="line">    <span class="string">"Accept: application/vnd.github.v3.full+json"</span>,</span><br><span class="line">    <span class="string">"User-Agent: Retrofit-Sample-App"</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="annotation">@GET</span>(<span class="string">"users/&#123;username&#125;"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Path(<span class="string">"username"</span>)</span> String username)</span>;</span><br></pre></td></tr></table></figure>
<p>注意：请求头部之间不会被重写，所有相同名字的Header都会被包含到请求中。<br>请求头部可以通过 <strong>Header</strong> 注解来进行动态更新，如果参数的对象值为null，该头部将会被忽略；否则会调用 <strong>toString()</strong> 方法来取得值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GET</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="function">Call&lt;User&gt; <span class="title">getUser</span><span class="params">(@Header(<span class="string">"Authorization"</span>)</span> String authorization)</span></span><br></pre></td></tr></table></figure>
<p><strong>每个请求都使用的头部Header可以使用<a href="https://github.com/square/okhttp/wiki/Interceptors" target="_blank" rel="external">OkHttp interceptor</a>来指定</strong></p>
<h4 id="同步_VS_异步">同步 VS 异步</h4><p><strong>Call</strong> 的实例既可以同步执行，也可以异步执行；每个实例只能使用一次，可以调用 <strong>clone()</strong> 方法来创建一个新的实例使用。<br>在Android上，回调(callbacks)会在主线程中执行；在JVM中，回调会在执行HTTP请求的线程中执行。</p>
<h2 id="Retrofit_配置">Retrofit 配置</h2><p><strong>Retrofit</strong> 是一个可以把你的API接口转换成可被调用的对象的类。默认情况下，Retrofit会为你的平台提供合理的默认配置，同时它也支持自定义配置。</p>
<h4 id="转换器(Converters)">转换器(Converters)</h4><p>默认情况下，Retrofit只能将HTTP请求体反序列化成OkHttp的 <strong>RetrofitBody</strong> 类型，而且 <strong>@Body</strong> 也只接受 <strong>RetrofitBody</strong> 类型。<br>添加转化器可以支持其他的类型。为了方便使用，以下六个流行的序列化库已被支持(retrofit 2)。</p>
<ul>
<li><strong><a href="https://github.com/google/gson" target="_blank" rel="external">Gson</a></strong> : com.squareup.retrofit2:converter-gson</li>
<li><strong><a href="http://wiki.fasterxml.com/JacksonHome" target="_blank" rel="external">Jackson</a></strong> : com.squareup.retrofit2:converter-jackson</li>
<li><strong><a href="https://github.com/square/moshi/" target="_blank" rel="external">Moshi</a></strong> : com.squareup.retrofit2:converter-moshi</li>
<li><strong><a href="https://developers.google.com/protocol-buffers/" target="_blank" rel="external">ProtocolBuf</a></strong> : com.squareup.retrofit2:converter-protobuf</li>
<li><strong><a href="https://github.com/square/wire" target="_blank" rel="external">Wire</a></strong> : com.squareup.retrofit2:converter-wire</li>
<li><strong><a href="http://simple.sourceforge.net/" target="_blank" rel="external">Simple XML</a></strong> : com.squareup.retrofit2:converter-simplexml</li>
</ul>
<p>一个使用 <strong>GsonConverterFactory</strong> 类来生成 <strong>GitHubService</strong> 实例的例子。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br><span class="line"></span><br><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br></pre></td></tr></table></figure>
<h4 id="自定义转化器">自定义转化器</h4><p>如果与API的通信使用了Retrofit不支持的格式的内容，或者希望使用一个不同序列化库，那么就需要创建一个自定义的Converter。集成 <strong>Converter.Factory</strong> 类创建一个新类，并且在build Retrofit的时候传入该类的实例。</p>
<h2 id="参考资料">参考资料</h2><ul>
<li>译自<a href="http://square.github.io/retrofit/" target="_blank" rel="external">Retrofit官网</a> (翻译官方Doc时的Retrofit版本为2.0.1，一切更新以官网为准)</li>
</ul>
</div></article></div></section><footer><div class="paginator"><a href="/2016/07/22/SpannableString.setSpan 非常规探索/" class="prev">上一篇</a><a href="/2016/04/01/genymotion-arm-translation/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2016 <a href="http://hellopony.cn">PONY WEI</a>, unless otherwise noted.</p></div></footer><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML"></script></body></html>